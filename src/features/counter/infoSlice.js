import {createSlice} from '@reduxjs/toolkit';

const html = [
    {
        question: 'Как сделать части изображения интерактивными?',
        answer: 'при помощи Image Map.',
        code: "<map name=\"primary\">\n" +
            "  <area shape=\"circle\" coords=\"75,75,75\" href=\"left.html\">\n" +
            "  <area shape=\"circle\" coords=\"275,75,75\" href=\"right.html\">\n" +
            "</map>\n" +
            "<img usemap=\"#primary\" src=\"https://via.placeholder.com/350x150\" alt=\"350 x 150 pic\">"

    },
    {
        question: 'Doctype. Что это и для чего используется?',
        answer: 'Это обозначение типа документа. Первая строка в языках разметки, для "объяснения" интерпретатору с каким стандартом работать и как парсить',
        code: "<!-- HTML5 -->> \n" +
            "<!DOCTYPE html> \n" +
            "<!-- HTML4 --> \n" +
            "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\tСтрогий синтаксис HTML.\n" +
            "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\tПереходный синтаксис HTML.\n" +
            "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Frameset//EN\" \"http://www.w3.org/TR/html4/frameset.dtd\">\tВ HTML-документе применяются фреймы."
    },
    {
        question: 'Минимальная структура HTML страницы.',
        answer: 'HTML страница начинается  с объявления типа, далее следует тег html, внутри него есть тег head и body.',
        code: "\n" +
            "<!doctype html>\n" +
            "<html lang=\"en\">\n" +
            "<head>\n" +
            "    <meta charset=\"UTF-8\">\n" +
            "    <meta name=\"viewport\"\n" +
            "          content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\">\n" +
            "    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n" +
            "    <title>Document</title>\n" +
            "</head>\n" +
            "<body>\n" +
            "\n" +
            "</body>\n" +
            "</html>"
    },
    {
        question: 'Сeмантика в html.',
        answer: 'Существует большое количество тегов, необходимо использовать корректные теги для определенных задач. В HTML добавлены новые типы',
        code: "<article>\tОпределяет статью\n" +
            "<aside>\tОпределяет содержание в стороне от содержимого страницы\n" +
            "<details>\tОпределяет дополнительные сведения, которые пользователь может просматривать или скрывать\n" +
            "<figcaption>\tОпределяет заголовок для элемента <Figure>\n" +
            "<figure>\tЗадает автономное содержимое, например иллюстрации, диаграммы, фотографии, списки кодов и т.д.\n" +
            "<footer>\tОпределяет нижний колонтитул для документа или раздела\n" +
            "<header>\tЗадает заголовок для документа или раздела\n" +
            "<main>\tУказывает основное содержимое документа\n" +
            "<mark>\tОпределяет выделенный/выделенный текст\n" +
            "<nav>\tОпределяет навигационные ссылки\n" +
            "<section>\tОпределяет раздел в документе\n" +
            "<summary>\tОпределяет видимый заголовок для элемента <Details>\n" +
            "<time>\tОпределяет дату и время"
    },
    {
        question: 'Теги для смыслового и / или стилистического выделения текста.',
        answer: 'Например strong / em / b / i. Strong и em - семантические теги, необходимые для смыслового выделения текста. b и i исключительно визуально.',
        code: null
    },
    {
        question: '',
        answer: '',
        code: null
    }
]

const css = [
    {
        question: 'Псевдоэлемент',
        answer: 'Псевдоэлемент ы: :after, :before, :first-letter, :first-line. Например для выделение первой буквы',
        code: ".info-block {\n" +
            "  &__question:first-letter {\n" +
            "    color: var(--attention-color);\n" +
            "  }\n" +
            "}"
    },
    {
        question: 'Как добавить css (без фреймворков)?',
        answer: 'Есть 4 основных типа добавление css \n' +
            '   1. Инлайновый стиль (inline styles) Внутренний CSS. Добавляется в cам элемент \n ' +
            'Преимущества внутреннего CSS:\n' +
            '\n' +
            'Полезен для проверки и предпросмотра изменений.\n' +
            'Полезен для быстрых исправлений.\n' +
            'Меньше HTTP запросов.' +
            'Недостатки внутреннего CSS:\n' +
            '\n' +
            'Внутренние CSS должны быть применены для каждого элемента в отдельности.' +
            '   2. Глобальный стиль (global style). Добавляется в тег head. \n' +
            'Преимущества глобальных CSS:\n' +
            'Таблица стилей влияет только на одну страницу.\n' +
            'В глобальной CSS могут быть использованы классы и идентификаторы (ID).\n' +
            'Нет необходимости загружать несколько файлов. HTML и CSS могут быть в одном и том же файле. \n' +
            'Недостатки глобальных CSS:\n' +
            '\n' +
            'Увеличенное время загрузки страницы.\n' +
            'Подключается только к одной странице — неэффективно, если вы хотите использовать одну и ту же CSS для нескольких страниц.' +
            '   3. Подключения файла (external file) Внешний CSS. Подключение при помощи тега link \n' +
            'Преимущества внешних CSS:\n' +
            '\n' +
            'Меньший размер страницы HTML и более чистая структура файла.\n' +
            'Быстрая скорость загрузки.\n' +
            'Для разных страниц может быть использован один и тот же .css файл.' +
            'Недостатки внешних CSS:\n' +
            '\n' +
            'Страница может некорректно отображаться до полной загрузки внешнего CSS.' +
            '   4. Импорт файла (import inside CSS). Импортировать внутрь уже подключенного файла',
        code: "<!-- inline --> \n" +
            "<p style=\"color:white;\">Здесь что-нибудь полезное.</p> \n" +
            "<!-- global --> \n" +
            "<head>\n" +
            "  <style type=\"text/css\">\n" +
            "    .className {color: red; font-size: 2.5rem;}\n" +
            "  </style>\n" +
            "</head> \n" +
            "<!-- external --> \n" +
            "<head>\n" +
            "  <link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\" />\n" +
            "</head> \n" +
            "<!-- import --> \n" +
            "@import url;\n" +
            "@import url list-of-media-queries;\n" +
            "@import url supports( supports-query );\n" +
            "@import url supports( supports-query ) list-of-media-queries;"
    },
    {
        question: 'Позиционирование элемента',
        answer: 'Основные виды позиционирования - static, relative, absolute, fixed, sticky. Так же float меняет позиционирование. Свойство position со значением static элементам назначается по умолчанию. Это значение означает что элемент является не позиционированным, т.е. отображается как обычно (в потоке).\n' +
            '\n' +
            'Явная установка элементу CSS-свойства position: static может понадобиться только в том случае, когда нужно переопределить другое значение position установленное элементу.' +
            'Установка относительного позиционирования элементу осуществляется посредством задания ему CSS свойства position: relative.\n' +
            '\n' +
            'Относительно позиционированный элемент ведёт себя как элемент в потоке за исключением того, что его текущее положение можно при помощи определённых CSS свойств сместить. К этим CSS свойствам относятся left, top, right и bottom.' +
            'Установка абсолютного позиционирования элементу осуществляется посредством задания ему position: absolute.\n' +
            '\n' +
            'Этот тип позиционирования позволяет разместить элемент именно там, где вы хотите.\n' +
            '\n' +
            'Позиционирование выполняется относительно ближайшего позиционированного предка.' +
            'Задание элементу фиксированного позиционирования осуществляется посредством установки ему position: fixed.\n' +
            '\n' +
            'Фиксированное позиционирование похоже на абсолютное, но в отличии от него оно всегда привязывается к краям окна браузера (viewport), и остаётся в таком положении даже при скроллинге страницы.\n' +
            '\n' +
            'Фиксированное позиционирование применяется для закрепления на странице навигационных меню, кнопки «вверх», панелей с социальными кнопками и многого другого.'
    },
    {
        question: 'Как учитывать весь размер элемента?',
        answer: 'border-box'
    }
]

const js = [
    {
        question: 'Разница между null и undefined',
        answer: 'undefined («неопределенный») представляет собой значение по умолчанию:\n' +
            'переменной, которой не было присвоено значения, т.е. объявленной, но не инициализированной переменной;\n' +
            'функции, которая ничего не возвращает явно, например, console.log(1);\n' +
            'несуществующего свойства объекта.\n \n' +
            'null — это «значение отсутствия значения». null — это значение, которое присваивается переменной явно. В примере ниже мы получаем null, когда метод fs.readFile отрабатывает без ошибок',
        code: 'fs.readFile(\'path/to/file\', (e, data) => {\n' +
            '    console.log(e) // здесь мы получаем null\n' +
            'if(e) {\n' +
            '    console.log(e)\n' +
            '}\n' +
            '    console.log(data)\n' +
            '})'
    },
    {
        question: 'Типы данных',
        answer: 'В JavaScript есть 8 основных типов.\n' +
            '\n' +
            'number для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном ±(253-1).\n' +
            'bigint для целых чисел произвольной длины.\n' +
            'string для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.\n' +
            'boolean для true/false.\n' +
            'null для неизвестных значений – отдельный тип, имеющий одно значение null.\n' +
            'undefined для неприсвоенных значений – отдельный тип, имеющий одно значение undefined.\n' +
            'object для более сложных структур данных.\n' +
            'symbol для уникальных идентификаторов.\n' +
            'Оператор typeof позволяет нам увидеть, какой тип данных сохранён в переменной.\n' +
            '\n' +
            'Имеет две формы: typeof x или typeof(x).\n' +
            'Возвращает строку с именем типа. Например, "string".\n' +
            'Для null возвращается "object" – это ошибка в языке, на самом деле это не объект.',
        code: null
    },
    {
        question: 'Самый быстрый способ преобразовать в число',
        answer: 'Согласно MDN оператор "+"  является самым быстрым способом преобразования строки в число, поскольку он не выполняет никаких операций со значением, которое является числом.',
        code: null
    },
    {
        question: 'Что такое распространение события (Event Propagation)?',
        answer: 'Всплытие\n' +
            'Принцип всплытия очень простой.\n' +
            '\n' +
            'Когда на элементе происходит событие, обработчики сначала срабатывают на нём, потом на его родителе, затем выше и так далее, вверх по цепочке предков. ' +
            'Погружение\n' +
            'Существует ещё одна фаза из жизненного цикла события – «погружение» (иногда её называют «перехват»). Она очень редко используется в реальном коде, однако тоже может быть полезной.\n' +
            '\n' +
            'Стандарт DOM Events описывает 3 фазы прохода события:\n' +
            '\n' +
            'Фаза погружения (capturing phase) – событие сначала идёт сверху вниз.\n' +
            'Фаза цели (target phase) – событие достигло целевого(исходного) элемента.\n' +
            'Фаза всплытия (bubbling stage) – событие начинает всплывать.',
        code: null
    },
    {
        question: 'Что такое DOM?',
        answer: 'DOM или Document Object Model (объектная модель документа) — это прикладной программный интерфейс (API) для работы с HTML и XML документами. Когда браузер первый раз читает («парсит») HTML документ, он формирует большой объект, действительно большой объект, основанный на документе — DOM. DOM представляет собой древовидную структуру (дерево документа). DOM используется для взаимодействия и изменения самой структуры DOM или его отдельных элементов и узлов.',
        code: null
    },
    {
        question: 'В чем разница между методами event.preventDefault() и event.stopPropagation()?',
        answer: 'Метод event.preventDefault() отключает поведение элемента по умолчанию. Если использовать этот метод в элементе form, то он предотвратит отправку формы (submit). Если использовать его в contextmenu, то контекстное меню будет отключено (данный метод часто используется в keydown для переопределения клавиатуры, например, при создании музыкального/видео плеера или текстового редактора — прим. пер.). Метод event.stopPropagation() отключает распространение события (его всплытие или погружение).',
        code: null
    },
    {
        question: 'Что такое область видимости (Scope)?',
        answer: 'Область видимости — это место, где (или откуда) мы имеем доступ к переменным или функциям. JS имеем три типа областей видимости: глобальная, функциональная и блочная (ES6).',
        code: null
    }
]

const vue = [
    {
        question: 'На каком шаблоне проектирования основан Vue?',
        answer: 'Vue.js основан на шаблоне проектирования Model-View-ViewModel(он же MVVM), основной мотивацией для этого шаблона является  отделение модели от представления.',
        code: null
    },
    {
        question: 'Что такое двухстороннее связывание?',
        answer: 'Связь данных с отображением и наоборот, связь отображенных данных с данными в компоненте',
        code: "<input v-model=\"message\" placeholder=\"отредактируй меня\" />\n" +
            "<p>Сообщение: {{ message }}</p>"
    },
    {
        question: 'Реактивность Vue',
        answer: 'Vue3 - прокси (js object). Vue2 - property (Object.defineProperty), все поля data имеют пару геттер-сеттер',
        code: null
    },
    {
        question: 'Композиция (Composition API) во Vue3',
        answer: ''
    }
]

const react = [
    {
        question: 'Что такое Виртуальная DOM?',
        answer: 'Виртуальная DOM является представлением реальной DOM в памяти. React создает кэш структуры данных в памяти, вычисляет результирующие различия и затем эффективно обновляет отображаемую DOM браузера. Это позволяет программисту писать код, как будто вся страница отображается при каждом изменении, в то время как библиотеки React отображают только те подкомпоненты, которые действительно изменяются.',
        code: null
    }
]



const initialState = {
    activeInfo: {},
    htmlInfo: {
        name: 'HTML',
        description: 'lorem3',
        blocks: html
    },
    cssInfo: {
        name: 'CSS',
        description: 'lorem55',
        blocks: css
    },
    jsInfo: {
        name: 'JavaScript',
        description: 'lorem',
        blocks: js
    },
    vueInfo: {
        name: 'Vue',
        description: 'lorem',
        blocks: vue
    },
    reactInfo: {
        name: 'React',
        description: 'lorem',
        blocks: react
    }
};

export const infoSlice = createSlice({
    name: 'info',
    initialState,
    // The `reducers` field lets us define reducers and generate associated actions
    reducers: {
        changeInfo: (state, action) => {
            const block = action.payload;
            state.activeInfo = state[block];
        },


    },

});

export  const {changeInfo} = infoSlice.actions;

export default infoSlice.reducer;
